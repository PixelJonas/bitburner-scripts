import { NS } from "@ns";
import { getAllServers } from "lib/scan";
import { getFreeRAMBotNet } from "lib/metrics";
import { DEFAULT_PCT, MIN_HOME_RAM } from "lib/contants";

const MAX_SECURITY_DRIFT = 3;
const MAX_MONEY_DRIFT_PCT = 0.1;

export async function main(ns: NS): Promise<void> {

  ns.disableLog("ALL");

  let xpMode = false;

  const [target, pct = DEFAULT_PCT] = ns.args;
  // Show usage if no parameters were passed
  if (target == undefined) {
    ns.tprint('ERROR: No server specified!');
    ns.tprint('INFO : Usage: run v1.js <server> <pct>');
    ns.tprint('INFO :    <server> is the name of the target server');
    ns.tprint('INFO :    <pct> is the 1-based maximum percentage to hack from the target (Optional, default is 25%)');
    ns.tprint('INFO :');
    ns.tprint('INFO : XP MODE: run v1.js xp');
    ns.tprint('INFO :    This mode will simply prepare and then throw all the ram on grow at joesguns for XP');
    return;
  }

  // If the user passes xp as a target, we grow joesguns for XP
  if (target == 'xp') {
    xpMode = true;
  }

  // This script calls 1-liner worker scripts, the following commands create those scripts on the current host
  await createScript(ns, 'hack');
  await createScript(ns, 'grow');
  await createScript(ns, 'weaken');

  // Open the tail window when the script starts
  //ns.tail();

  await exploit(ns, target as string, pct as number, xpMode);
}

async function exploit(ns: NS, target: string, pct: number, xpMode: boolean) {
  if (xpMode) target = 'joesguns';

  let hackedOnce = false;

  while (true) {
    //Security
    const minimalSecurity = ns.getServerMinSecurityLevel(target);
    const currentSecurity = ns.getServerSecurityLevel(target);
    let weakenThreads = Math.ceil((currentSecurity - minimalSecurity) / ns.weakenAnalyze(1));

    //Money
    let currentMoneyAvailable = ns.getServerMoneyAvailable(target);
    if (currentMoneyAvailable <= 0) currentMoneyAvailable = 1;
    const maxMoney = ns.getServerMaxMoney(target);
    let growThreads = Math.ceil(ns.growthAnalyze(target, maxMoney / currentMoneyAvailable));

    //Hacking
    let hackThreads = Math.floor(ns.hackAnalyzeThreads(target, currentMoneyAvailable * pct));

    if (xpMode) {
      if (weakenThreads > 0) weakenThreads = Infinity;
      growThreads = Infinity;
      hackThreads = 0
    }

    // Report
    ns.print('');
    ns.print(target);
    ns.print('INFO: Money    : ' + ns.formatNumber(currentMoneyAvailable) + ' / ' + ns.formatNumber(maxMoney) + ' (' + (currentMoneyAvailable / maxMoney * 100).toFixed(2) + '%)');
    ns.print('INFO: Security : ' + (currentSecurity - minimalSecurity).toFixed(2));
    ns.print('INFO: Weaken   : ' + ns.tFormat(ns.getWeakenTime(target)) + ' (t=' + weakenThreads + ')');
    ns.print('INFO: Grow     : ' + ns.tFormat(ns.getGrowTime(target)) + ' (t=' + growThreads + ')');
    ns.print('INFO: Hack     : ' + ns.tFormat(ns.getHackTime(target)) + ' (t=' + hackThreads + ')');
    ns.print('');

    let startedAnything = false;

    if ((xpMode || (currentSecurity > minimalSecurity + MAX_SECURITY_DRIFT)) && weakenThreads > 0) {
      // we need to lower security first
      ns.print('WARN: ***WEAKENING*** Security is over threshold, we need ' + weakenThreads + ' threads to floor it');
      let pids = await RunScript(ns, "v1weaken.js", target, weakenThreads, hackedOnce);
      if (pids.length > 0 && pids.find(active => active != 0)) {
        startedAnything = true;
      }

      ns.print(`INFO: Waiting for script completion (approx: ${ns.tFormat(ns.getWeakenTime(target))})`);
      await waitForPids(ns, pids);
    } else if ((currentMoneyAvailable < maxMoney - maxMoney * MAX_MONEY_DRIFT_PCT) && growThreads > 0 || xpMode) {
      /// we need to grow the server
      ns.print(`WARN: ***GROWING*** Money is getting low, we need ${growThreads} threads to max it`);
      let pids = await RunScript(ns, "v1grow.js", target, growThreads, hackedOnce);
      if (pids.length > 0 && pids.find(pid => pid != 0)) {
        startedAnything = true;
      }

      if (hackedOnce) await printMemoryReport(ns);
      ns.print(`INFO: Waiting for script completion (approx ${ns.tFormat(ns.getGrowTime(target))})`);
      await waitForPids(ns, pids);
    } else if (hackThreads > 0) {
      ns.print(`WARN: ***HACKING*** Server is ready to be hacked, hitting the target will require ${hackThreads} threads`);
      let pids = await RunScript(ns, "v1hack.js", target, hackThreads, hackedOnce);
      if (pids.length > 0 && pids.find(pid => pid != 0)) {
        startedAnything = true;
      }
      hackedOnce = true;
      ns.print(`INFO: Waiting for script completion (approx ${ns.tFormat(ns.getHackTime(target))})`);
      await waitForPids(ns, pids);
    }

    if (!startedAnything) {
      ns.print(`FAIL: ***STALLING*** Could not start any scripts. This is most likely due to not having enough RAM. Waiting for more RAM`);
      await ns.sleep(1000);
    }


  }
}

async function RunScript(ns: NS, scriptName: string, target: string, threads: number, hackedOnce: boolean): Promise<number[]> {
  const allServers = await getAllServers(ns);
  allServers.sort((a, b) => ns.getServerMaxRam(b.hostname) - ns.getServerMaxRam(a.hostname));
  allServers.push(ns.getServer("home"));
  const ramPerThread = ns.getScriptRam(scriptName);

  const usableServers = allServers.filter(server => ns.hasRootAccess(server.hostname) && ns.getServerMaxRam(server.hostname) > 0);

  let active = 0;
  let pids: number[] = [];

  for (let server of usableServers) {
    let availableRam = server.maxRam - server.ramUsed;
    if (server.hostname == "home") {
      availableRam -= MIN_HOME_RAM(ns);
      if (availableRam < 0) availableRam = 0;
    }

    let possibleThreads = Math.floor(availableRam / ramPerThread);

    if (possibleThreads <= 0) continue;

    //Lower Threadcount if we are over the target
    if (possibleThreads > threads - active) possibleThreads = threads - active;
    if (server.hostname != ns.getHostname()) await ns.scp(scriptName, server.hostname);

    // Start Script with as many threads as possible
    ns.print(`INFO: Starting script ${scriptName} on ${server.hostname} with ${possibleThreads} threads`);

    let pid: number = ns.exec(scriptName, server.hostname, possibleThreads, target);
    if (pid == 0) {
      ns.print(`WARN: Could not start script ${scriptName} on ${server.hostname} with ${possibleThreads} threads`);
    } else {
      active += possibleThreads;
      ns.print(`INFO: successfully started ${pid} on ${server.hostname}`);
      pids.push(pid);
      ns.print(`INFO: Current running pids = ${pids.toString()}`)
    }

    if (active >= threads) break;
  }

  if (active == 0) {
    ns.print(`FAIL: Not enough memory to launch a single thread of ${scriptName} (all servers are OOM)`);
  }

  if (hackedOnce && active != threads) {
    ns.print(`FAIL: There wasn't enough RAM to run ${threads} threads of ${scriptName} (active: ${active}). It is recommended to either reduce the hack percentage or reduce memory usage from other scripts.`);
  }

  return pids;

}

async function createScript(ns: NS, command: string): Promise<void> {
  await ns.write('v1' + command + '.js', 'export async function main(ns) { await ns.' + command + '(ns.args[0]) }', 'w');
}


async function waitForPids(ns: NS, pids: number[]) {
  if (!Array.isArray(pids)) pids = [pids];
  for (; ;) {
    let isRunning = false;
    for (const pid of pids) {
      const process = ns.getRunningScript(pid);
      if (process != undefined) {
        isRunning = true;
        break;
      }
      await ns.sleep(0);
    }
    if (!isRunning) return;
    await ns.sleep(5);
  }
}

async function printMemoryReport(ns: NS) {
  let botNetStats = await getFreeRAMBotNet(ns);
  if (botNetStats.used / botNetStats.total < 0.85) {
    ns.print(`WARN: The full grow cycle for this hacking job is running with ${botNetStats.freePercentage}% RAM left. You could hack other servers, and/or increase the % hack of this server`);
  }
}

